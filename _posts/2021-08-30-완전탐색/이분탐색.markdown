---
layout: post
title: week2- 완전탐색/이분탐색
date: 2021-08-30 19:20:23 +0900
category: programmers
---
# 완전탐색/이분탐색

#탐색(검색)
  : 많은 데이터 속에서 원하는 데이터를 찾는것  
    ex) 웹에서 특정 문자를 가진 웹 문서를 찾기, 신용카드, 버스카드

#탐색의 종류  
  1) 완전탐색  
  2) 이분탐색        #이번시간에 여기까지  
  3) 깊이우선탐색  
  4) 너비우선탐색  
  5) 문자열 탐색  
  6) KMP  
  7) BM  

#완전탐색
  - 브루트(brute/짐숭같은) 포스(Force)라고 불리며 컴퓨터의 빠른 계산 성능을 활용하여  
      가능한 모든 경우의 수를 탐색  
  - 효율성관점에서 최악  

#완전탐색의 구현방법
  - 반복문  
  - 재귀함수    
    -> 동적계획법, 백트래킹, 탐욕법    

#완전탐색 예시  
  ex) 카드 n장이 있을때 원하는 카드가 나올때까지 계속 뒤집을 때   
      카드의 수가 많을 경우 어떤 카드를 뒤집었는지 안뒤집었는지 파악하기 어려움  
      따라서  
      -> 하나의 방향에 따라 원하는 카드가 나올때까지 뒤집고 진행하기를 반복  

#Python 완전탐색 반복문 직접 구현 예시  
-> #완전탐색  

```python
   def solution(trump):
       for i in range(len(trump)):
           if trump[i] == 8:
               return i
       return -1
```  

#Python 완전탐색 재귀함수 직접 구현 예시  
-> #재귀함수  
    : 다양한 방면에서 활용 가능하지만 쉽게 무한루프에 빠지는 경향이 있음  

```python
    def solution(trump, loc):    
        for i in range(len(trump)):
            if trump[loc] == 8:
                return loc
            else:
                #트럼프의 다음위치 탐색
                return solution(trump, loc+1)
  print('=============================================')
    #loc은 변수명을 기준으로 데이터프레임 분리 
     df.loc["row","column"]
    #iloc은 인덱스 값을 기준으로 데이터프레임 분리
     df.iloc[0,0]
```

#이분탐색
  - 이진검색이라고도 표현하며 오름차순으로 """정렬된 리스트"""에서  
    특정값의 위치를 찾는 알고리즘 중간의 값을 선택해 찾고자 하는 값과  
    크고 작음을 비교  
    ex) updown game  
  - 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 x와 비교.  
    x가 중간값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로 하고  
    x가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색을 하며 해당값을 탐색  

#이분탐색 예시  
  ex) 순서대로 정렬된 카드리스트가 있고 원하는 카드가 나올때까지 특정 규칙에 따라 뒤집음  
      가장 작은 인덱스 0(=left)을 지정하고 가장 큰 인덱스값(right)를 지정하고  
      중앙값인 mid(left+right/2)를 지정.  
      - 리스트의 길이가 홀수일 경우 반올림 (left+right/2)  
                리스트의 길이가 짝수일 경우 round(left+right/2)  
      - 혹은 홀짝 모두 (left+right)//2로 처리  
      mid에서 얻은 값을 구하고자 하는 값을 기준으로 left값을 재지정  

```python
      0턴 [?,?,?,?,?,?,?,?,?]  >> 정렬된 리스트
      1턴 [?,?,?,?,5,?,?,?,?]  >> 5 < 8    
          (l)eft  (m)id   (r)ight
         #이전 mid+1로 left값 재지정
      2턴 [?,?,?,?,?,?,7,?,?]  >> 7 < 8    
                     l|m|  r
         #이전 mid+1로 left값 재지정
      3턴 [?,?,?,?,?,?,?,8,?]  >> 8 == 8    
                         l|r
                         m
          #반복 종료 
```     

#Python 이분탐색 직접 구현 예시  
-> #이분탐색  
```python
    def solution(trump):
        left = 0  #함수 시작시 선언
        right = len(trump)-1  #함수 시작시 선언
        find_answer = 8
        while(left<=right):  # left가 right 보다 작거나 같다면
            mid = (left<=right)//2
            if trump[mid] == 8:  #정답 검출
                return mid   
            elif trump[mid] < 8:  #중앙값이 찾고자 하는 값보다 작을 경우 
                left = mid + 1  #탐색 범위를 우측으로 좁힘
            elif trump[mid] > 8:  #중앙값이 찾고자 하는 값보다 클 경우
                right = mid - 1  #탐색범위를 좌측으로 좁힘
        return mid
```