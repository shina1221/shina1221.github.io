---
layout: post
title: 배열과 리스트
date: 2024-06-02 19:20:23 +0900
category: Algorithm
---
# 시간 복잡도 표기법 알아보기
> Do it! 알고리즘 코딩 테스트 

(파이썬 기준) 1초의 수행시간: 2000만번 ~ 1억번 연산횟수  
<br>  
빅 오메가:최선일 때 연산 횟수  
빅 세타:보통일 때 연산 횟수  
빅 오: 최악일 때 연산 횟수  
<br>  
코딩테스트에선 주로 빅 오 표기법을 따른다.  
<br>
```python
N= 10
cnt=1
<br>
for i in range(N):
   cnt+=1
```  
<br>  
```python
N= 10
cnt=1
<br>
for i in range(N):
   cnt+=1
<br>
for i in range(N):
   cnt+=1
```  
<br>  
두 예제 코드는 연산 횟수가 2개 차이날 것 같지만  
코딩테스트에서 일반적으로 상수를 무시한다.
따라서 두 코드 모두 시간 복잡도는 O(N)이 된다.  
<br>  
시간복잡도는 가장 많이 중첩된 반복문을 기준으로 도출한다.  
<br>
배열: 메모리의 연속공간에 값이 채워져 있는 형태의 자료구조  
배열의 값은 인덱스를 통해 참조할 수 있고 선언한 자료형의 값만 저장할 수 있다.  
<br>  
배열의 특징  
- 인덱스를 사용해 값에 접근할 수 있다.  
- 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.  
- 배열의 크기는 선언할 때 지정할 수 있으며 한 번 선언하면 크기를 늘리거나 줄일 수 없다.  
- 구조가 간단하다.  
<br>  
리스트: 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.  
<br>
리스트의 특징  
- 인덱스가 없으므로 값에 접근하려면 헤드 포인터부터 순서대로 접근해야 한다. 따라서 값에 접근하는 속도가 느리다.  
- 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.  
- 선언할 때 크기를 별도로 지정하지 않아도 된다. 리스트의 크기는 정해져 있지 않고, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.  
- 포인터를 저장할 공간이 필요하므로 배열 구조가 복잡하다.  
<br>  
파이썬에서는 배열과 리스트를 구분하지 않지만 알아두도록 하자.  
<br>   
> 백준 온라인 저지 ![11720](https://www.acmicpc.net/problem/11720)  

```python
import sys
n=sys.stdin.readline().strip()
answer = sum(map(int,list(sys.stdin.readline().strip())))
print(answer)
```
<br>
1 2 3  
2 3 4 라는 배열이 있을 때  
<br>  
1 3 6  
3 8 15여기서 8이 나오는데  
(1+2)+(1+2)+3-(중복된 1)=8이 된다.  
<br>  
15의 경우  
8+6+4-3(중복된 3)=15가 나오게 된다. 
<br>
**matrix[i][j]까지의 구간합= matrix[i][j-1]까지의 구간합+matrix[i-1][j]까지의 구간합+matrix[i][j]-matrix[i-1][j-1]까지의 구간합**  
                         = 현재 기준 왼쪽값 + 현재 기준 위쪽 값 + 현재 값 - 현재 기준 왼쪽 대각선에 있는 값  
<br>
<br>                           
그렇다면 (1,2)부터 (2,3)까지의 구간합은 어떻게 구할까?  
(2,3)까지의 구간합-(1,2)까지의 구간합으로 계산하기에는 기존에 (1,2)까지의 구간합에 (2,3)까지의 구간합에 해당하는 (1,1)부분이 존재한다. 
(8+6+4-3)-(1+2)=12  
(1+2+3+2+3+4)-(1+2)=12  
<br>  
(X1,Y1)에서 (X2,Y2)까지의 구간합 = (X1,Y1)수부터 (X2,Y2)수까지의 합  
                               **= m(atrix)[X2][y2]구간합-m[X1-1][y2]-m[X2][Y1-1]+m[X1-1][Y1-1]**  
                                 =(2,3)까지의 구간합-(0,3)구간합[행 구간합]-(2,1)구간합[열 구간합]+(0,2)구간합[중복값 구간합]  
                                 #x나 y에서 0이 나오면 이는 matrix를 벗어나는 값으로 간주하고 0으로 간주한다.  
                                 =15-0-3+0=12   
<br>
![구간합 구하기 매커니즘](https://github.com/shina1221/shina1221.github.io/blob/7f145a5d0660bb8c973c60e94f124b815fbc98d1/_posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/img/%EA%B5%AC%EA%B0%84%ED%95%A9%20%EA%B5%AC%ED%95%98%EA%B8%B0.jpg)

> 백준 온라인 저지 ![11660번](https://www.acmicpc.net/problem/11660)   

```python

```
시간제한이 2초이므로 4000만번 이하로 연산이 완료되어야 한다.  
  
#input으로 받으면 연산량에 차이가 생긴다.  
#sys.stdin.readline()  
  

