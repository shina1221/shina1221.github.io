---
layout: post
title: 배열과 리스트
date: 2024-06-02 19:20:23 +0900
category: Algorithm
---
# 시간 복잡도 표기법 알아보기
> Do it! 알고리즘 코딩 테스트 

(파이썬 기준) 1초의 수행시간: 2000만번 ~ 1억번 연산횟수  
<br>  
빅 오메가:최선일 때 연산 횟수  
빅 세타:보통일 때 연산 횟수  
빅 오: 최악일 때 연산 횟수  
<br>  
코딩테스트에선 주로 빅 오 표기법을 따른다.  
<br>
```python
N= 10
cnt=1
<br>
for i in range(N):
   cnt+=1
```  
<br>  
```python
N= 10
cnt=1
<br>
for i in range(N):
   cnt+=1
<br>
for i in range(N):
   cnt+=1
```  
<br>  
두 예제 코드는 연산 횟수가 2개 차이날 것 같지만  
코딩테스트에서 일반적으로 상수를 무시한다.
따라서 두 코드 모두 시간 복잡도는 O(N)이 된다.  
<br>  
시간복잡도는 가장 많이 중첩된 반복문을 기준으로 도출한다.  
<br>
배열: 메모리의 연속공간에 값이 채워져 있는 형태의 자료구조  
배열의 값은 인덱스를 통해 참조할 수 있고 선언한 자료형의 값만 저장할 수 있다.  
<br>  
배열의 특징  
- 인덱스를 사용해 값에 접근할 수 있다.  
- 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.  
- 배열의 크기는 선언할 때 지정할 수 있으며 한 번 선언하면 크기를 늘리거나 줄일 수 없다.  
- 구조가 간단하다.  
<br>  
리스트: 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.  
<br>
리스트의 특징  
- 인덱스가 없으므로 값에 접근하려면 헤드 포인터부터 순서대로 접근해야 한다. 따라서 값에 접근하는 속도가 느리다.  
- 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.  
- 선언할 때 크기를 별도로 지정하지 않아도 된다. 리스트의 크기는 정해져 있지 않고, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.  
- 포인터를 저장할 공간이 필요하므로 배열 구조가 복잡하다.  
<br>  
파이썬에서는 배열과 리스트를 구분하지 않지만 알아두도록 하자.  
<br>   
> 백준 온라인 저지 [11720](https://www.acmicpc.net/problem/11720)  

```python
import sys
n=sys.stdin.readline().strip()
answer = sum(map(int,list(sys.stdin.readline().strip())))
print(answer)
```
<br>
1 2 3  
2 3 4 라는 배열이 있을 때  
<br>  
1 3 6  
3 8 15여기서 8이 나오는데  
(1+2)+(1+2)+3-(중복된 1)=8이 된다.  
<br>  
15의 경우  
8+6+4-3(중복된 3)=15가 나오게 된다. 
<br>
**matrix[i][j]까지의 구간합= matrix[i][j-1]까지의 구간합+matrix[i-1][j]까지의 구간합+matrix[i][j]-matrix[i-1][j-1]까지의 구간합**  
                         = 현재 기준 왼쪽값 + 현재 기준 위쪽 값 + 현재 값 - 현재 기준 왼쪽 대각선에 있는 값  
<br>
<br>                           
그렇다면 (1,2)부터 (2,3)까지의 구간합은 어떻게 구할까?  
(2,3)까지의 구간합-(1,2)까지의 구간합으로 계산하기에는 기존에 (1,2)까지의 구간합에 (2,3)까지의 구간합에 해당하는 (1,1)부분이 존재한다. 
(8+6+4-3)-(1+2)=12  
(1+2+3+2+3+4)-(1+2)=12  
<br>  
(X1,Y1)에서 (X2,Y2)까지의 구간합 = (X1,Y1)수부터 (X2,Y2)수까지의 합  
                               **= m(atrix)[X2][y2]구간합-m[X1-1][y2]-m[X2][Y1-1]+m[X1-1][Y1-1]**  
                                 =(2,3)까지의 구간합-(0,3)구간합[행 구간합]-(2,1)구간합[열 구간합]+(0,2)구간합[중복값 구간합]  
                                 #x나 y에서 0이 나오면 이는 matrix를 벗어나는 값으로 간주하고 0으로 간주한다.  
                                 =15-0-3+0=12   
<br>
![구간합 구하기 매커니즘](https://github.com/shina1221/shina1221.github.io/blob/7f145a5d0660bb8c973c60e94f124b815fbc98d1/_posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/img/%EA%B5%AC%EA%B0%84%ED%95%A9%20%EA%B5%AC%ED%95%98%EA%B8%B0.jpg)
<br>

> 백준 온라인 저지 [11660번](https://www.acmicpc.net/problem/11660)   

```python
matrix = []
#input().strip().split() -> sys.stdin.readline().strip().split() 
#N,M = map(int,sys.stdin.readline().strip().split())
N,M = map(int,input().strip().split())

for i in range(N+1):
    if i==0:
        #matrix[i]=[0]*(N+1)로 추가하면 리스트는 배열이 아니다. 
        #인덱스가 없는 자료형이기 때문에 에러가 나므로 append해준다. 
        matrix.append([0]*(N+1))
    else:
        #map함수는 map 객체로 나오므로 list처리를 하거나 변수에 할당해줄 필요가 있다. 
        matrix.append(list(map(int, input().strip().split())))
        matrix[i].insert(0,0) #0번째 자리에 0을 추가한다.

#확인용        
weighted_sum_matrix= matrix.copy()
weighted_sum_matrix    

#위에서 본 매커니즘을 적용한다. 
#현재값+위쪽값+왼쪽값-왼쪽상단값
for wi in range(1,N+1):
    for wj in range(1,N+1):
        weighted_sum_matrix[wi][wj]=weighted_sum_matrix[wi][wj]+weighted_sum_matrix[wi-1][wj]+weighted_sum_matrix[wi][wj-1]-weighted_sum_matrix[wi-1][wj-1] 

weighted_sum_matrix= matrix.copy()
weighted_sum_matrix    

for j in range(M):
    x1, y1, x2, y2 = map(int, input().strip().split())
    answer = weighted_sum_matrix[x2][y2]-weighted_sum_matrix[x1-1][y2]-weighted_sum_matrix[x2][y1-1]+weighted_sum_matrix[x1-1][y1-1]
    print(answer)
```
시간제한이 1초이므로 2000만번 이하로 연산이 완료되어야 한다.  
<br>  
#input으로 받으면 연산량에 차이가 생긴다.  
#sys.stdin.readline()  
<br>  
```python
import sys
N,M = map(int,sys.stdin.readline().strip().split())
matrix = []

for i in range(N+1):
    if i==0:
        matrix.append([0]*(N+1))
    else:
        matrix.append(list(map(int, sys.stdin.readline().strip().split())))
        matrix[i].insert(0,0) 
            
for wi in range(1,N+1):
    for wj in range(1,N+1):
        matrix[wi][wj]=matrix[wi][wj]+matrix[wi-1][wj]+matrix[wi][wj-1]-matrix[wi-1][wj-1] 
        
for j in range(M):
    x1, y1, x2, y2 = map(int, sys.stdin.readline().strip().split())
    answer = matrix[x2][y2]-matrix[x1-1][y2]-matrix[x2][y1-1]+matrix[x1-1][y1-1]
    print(answer)
```
<br>  
투 포인터:2개의 포인터로 알고리즘의 시간 복잡도를 최적화  
<br>  
> 백준 온라인 저지 [11660번](https://www.acmicpc.net/problem/1253)   

포인트: 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안된다.  
예시)1 2 3 4 5가 있을 때   
1, 2의 경우 이를 기준으로 두개의 값을 더해서 만들 수 있는 경우가 없다.  
3을 기준으로 1과 2를 더해 3을 만들 수 있다. (다음으로 넘어간다.)  
4를 기준으로 1과 3을 더해 4를 만들 수 있다. (다음으로 넘어간다.)  
5를 기준으로 1과 4, 2와 3을 더해 5를 만들 수 있지만 1과 4라는 케이스가 보이면 바로 다음으로 넘어간다.  
최종적으로 3,4,5 3개가 좋은 수로 남는다.  
<br>  

```python
import sys
#input=sys.stdin.readline()
N= int(input())
result = 0
A= list(map(int,input().split()))
A.sort()

for k in range(N):
    find = A[k]
    i=0
    j=N-1
    #for문으로 작성하면 연산량이 얼마나 될 지 모르므로 while로 한다. 
    while i<j: #투 포인터
        if A[i]+A[j] == find: #좋은 수는 서로 다른 두 수가 합쳐져서 좋은 수가 나왔을 때 
            if i != k and j != k: #두 수 모두 좋은수가 포함되지 않았을 때  
                result +=1
                break
            #포인트 (시간초과 잡기)
            #두 합쳐지는 수 중에 좋은 수가 포함되어 있다면 포인터 이동 
            elif i == k: 
                i += 1 #왼쪽에서 오른쪽으로 (작은수에서 더 큰 수로)
            elif j == k: 
                j -=1 #오른쪽에서 왼쪽으로 (큰 수에서 더 작은 수로)
        #좋은 수가 만들어지지 않았을 경우 계속해서 포인터 조정
        elif A[i] + A[j] <find : #두 수를 합쳐도 좋은 수보다 작다면 
            i+=1 #두 수 중에서 작은 수를 키운다. 
        #좋은 수가 만들어지지 않았을 경우 계속해서 포인터 조정
        else: #두 수를 합쳐서 좋은 수보다 크다면 
            j -=1 #두 수 중에서 큰 수를 키운다. 
```

