---
layout: post
title: 인덱스
date: 2023-08-24 19:20:23 +0900
category: CS
---
# 면접을 위한 CS 전공지식 노트  
> 인덱스의 필요성    

인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.  
인덱스는 보통 B트리라는 자료구조로 이뤄져있다.  
   
B-트리: 
B 트리는 루트 노드, 브랜치 노드, 리프 노드로 구분된다.  
트리 탐색은 맨 위 노드인 루트 노드 부터 탐색이 시작된다. 브랜치 노드를 거쳐  
리프노드까지 내려와 데이터 포인터가 가리키는 결과값을 반환하게 된다.  

> 인덱스가 효율적인 이유와 대수확장성  

인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌  
트리 구조와 트리 깊이의 대수확장성 때문이다.  
*대수확장성:트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것이다.  
기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.  
트리깊이가 하나씩 늘어날 때마다 4제곱 만큼 인덱스 항목의 수가 늘어난다.  
    
> 인덱스 만드는 방법

MySQL: 클러스터형 인덱스와 세컨더리 인덱스가 존재한다.  
클러스터형 인덱스는 테이블당 하나를 설정할 수 있다. primary key 옵션으로 기본키로   만들려면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을  
붙이면 클러스터형 인덱스로 만들 수 있다.  
create index 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다.  
다만 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는게 성능이 더 좋다.  
세컨더리 인덱스는 보조 인텍스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때  
생성해야 하는 인덱스이다. 
ex) age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하다.  
하지만 age, name, email 등 다양한 필드기반으로 쿼리를 보낼 시 세컨더리 인덱스를 사용해야 한다.  

MongoDB: 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키가 된다.  
또한 세컨더리키도 부가적으로 설정해 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할  
수 있다.  
  
>인덱스 최적화 기법  

인덱스는 두번 탐색하도록 강요한다. 인덱스 리스트, 그 다음에 컬렉션 순으로 탐색하기 때문에  
관련 읽기 비용이 들게된다. 또한 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.  
ex)책의 본문이 수정되면 목차도 수정되어야 한다.  
이 때 B트리의 높이를 균형 있게 조절하는 비용, 데이터를 효율적으로 조회할 수 있도록  
분산시키는 비용도 든다.  
  
서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 테스팅은 중요하다.  
explain()함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을  
최소화해야 한다.  
  
보통 여러필드를 기반으로 조회할 시 복합인덱스를 생성하는데  
이 인덱스를 생성할 때에는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.  
같음(==, equal), 정렬, 다중값(>,< 등 다중값 출력 필드), 카디널리티 순으로 생성해야한다.  
*카디널리티: 유니크한 값의 정도로 age와 email 중 email이 더 카디널리티가 높다.    
