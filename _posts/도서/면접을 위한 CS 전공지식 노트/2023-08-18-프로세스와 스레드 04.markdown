---
layout: post
title: 프로세스와 스레드 04
date: 2023-08-18 19:20:23 +0900
category: CS
---
# 면접을 위한 CS 전공지식 노트  
> 스레드와 멀티스레딩  

스레드: 프로세스의 실행 가능한 가장 작은 단위이다.  
프로세스는 여러 스레드를 가질 수 있다.  
코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와는 달리 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유한다. 그 외의 영역은 각각 생성된다.  
  
멀티스레딩: 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법이다.  
스레드끼리 서로 자원을 공유하기 때문에 효율성이 높다.  
Ex) 웹 요청을 처리할 대 새 프로세스를 생성하는 대신 스레드를 사용하는 웹 서버의 경우   
적은 소스를 소비하며 한 스레드가 중단(blocked)되어도 다른 스레드는(running) 상태일 수 있기  
때문에 중단되지 않은 빠른 처리가 가능해진다.  
동시성에도 장점이 있으나 한 스레드에서 문제가 생기면 다른 스레드에도 영향을 미쳐 스레드로  
이뤄져 있는 프로세스에 영향을 줄 수도 있다.  
Ex) 렌더러 프로세스: HTML, CSS, JS를 사용자가 인터렉션 할 수 있는 웹페이지로 만드는 것이다.  
이 프로세스 내에는 메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드가 존재한다.  
  
*데이터 병렬성: 전체 데이터를 쪼개 서브데이터로 만들어 서브데이터들을 병렬처리해 작업을  
빠르게 수행하는 것이다. 서브데이터는 멀티 코어의 수만큼 쪼개어 각각의 데이터들을  
분리된 스레드에서 병렬 처리한다.  
*작업 병렬성: 서로 다른 작업을 병렬 처리하는 것이다.  
Ex) 웹 서버가 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리하는 것이다.  
*동시성: 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것이다.  
스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가며  
실행되는 성질이다.  
  
> 공유자원과 임계영역  

공유자원: 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리,  
파일, 데이터 등의 자원이나 변수 등을 의미한다.  
이 공유자원을 두 개 이상의 프로세스에서 접근하려 할 때를 경쟁 상태(race condition)라고 한다.  
  
임계영역: 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 의미한다.  
임계영역을 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 세가지가 있다.  
이 방법들은 상호배제, 한정 대기, 융동성의 조건을 만족한다.  
이 방법들의 주된 메커니즘은 잠금(lock)이다.  
Ex) 임계 구역을 화장실이라고 가정하면 화장실에 A라는 사람이 들어간 다음 문을 잠근다.  
그리고 다음 사람이 이를 기다리다가 A가 화장실에서 나오면 화장실을 이용할 수 있다.  
*상호배제: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.  
*한정대기: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.  
*융통성: 한 프로세스가 다른 프로세스의 일을 방해해선 안된다.  
  
뮤텍스: 공유자원을 사용하기 전에 설정하고 사용한 후에는 해제하는 잠금이다.  
뮤텍스는 하나의 상태(잠금 혹은 해제)만 가진다.  
**공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는다.**  
  
세마포어: 간단한 정수 값과 두가지 함수 wait(P함수) 및 signal(v함수)로 공유자원에 대한 접근을  
처리한다. **공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는다.**  
Wait()는 자신의 차례가 올 때까지 대기하는 함수이다.  
Signal()은 다음 프로세스로 순서를 넘겨주는 함수다.  
프로세스가 공유자원에 접근하면 세마포어에서 wait() 작업을 수행하고  
프로세스가 공유자원을 해제하면 세마포어에서 signal() 작업을 수행한다.  
세마포어에는 조건변수가 없고 프로세스가 세마포어 값을 수정할 때 다른 프로세스는 동시에  
세마포어 값을 수정할 수 없다. 또한 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가  
될 수 없다.    
*조건변수: 멀티스레드 간의 동기화를 지원하는 것이다.    
  
바이너리 세마포어: 0과 1만 가질 수 있는 세마포어이다.  
구현의 유사성으로 뮤텍스와 헷갈리는 개념이나  
뮤텍스는 리소스에 대한 접근을 동기화하는데 사용되는 잠금 매커니즘이고,  
세마포어는 신호를 기반으로 상호배제가 일어나는 신호 메커니즘이다.  
Ex) 스마트폰으로 노래를 듣다가 연락이 오면 통화 작업 인터페이스가 등장하는 것이 있다.  
  
카운팅 세마포어  
여러 개의 값을 가질 수 있는 세마포어로 여러 자원에 대한 접근을 제어하는데 사용된다.  
  
모니터: 둘 이상의 스레드가 공유 자원에 안전하게 접근할 수 있도록 공유자원을 숨기고  
해당 접근에 대해 인터페이스만 제공한다.  
모니터큐를 통해 공유자원에 대한 작업들을 순차적으로 처리한다.  
모니터는 세마포어보다 구현하기 쉬우며 모니터에서 상호배제는 자동인 반면,  
세마포어에서는 상호배제를 명시적으로 구현해야 한다.  

> 교착 상태  

교착상태: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태이다.  
교착상태의 원인  
상호배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능하다.  
점유대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태이다.    
비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.  
환형대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을  
요구하는 등 서로가 서로의 자원을 요구하는 상황이다.  
  
교착상태의 해결 방법  
1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다.  
2. 교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스당 요청할 자원들의 최대치를 통해  
자원할당 가능여부를 파악하는 은행원 알고리즘을 쓴다.  
*은행원 알고리즘: 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정/불안정 상태로 나눠 안정 상태로 가도록 자원을 할당하는 알고리즘이다.  
3. 교착상태가 발생하면 사이클이 있는지를 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.  
4. 교착상태는 매우 드물게 일어나므로 이를 처리하는 비용이 더 커서 교착 상태가 발생하면  
사용자가 작업을 종료한다. 이는 현대 운영체제 방식이다.  
Ex) 프로세스에서 응답없음이 뜨는 것이 있다.  
  
> CPU 스케줄링 

CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로  
CPU에 할당한다. 프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU  
소유권을 줄 것인지 결정한다. 이 알고리즘은 이용률은 높게, 주어진 시간에 많은 일을 하도록  
준비 큐에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표로 한다.  
  
CPU 스케줄링 알고리즘  
비선점형      /          선점형  
FCFS, SJF, 우선순위    라운드로빈, SRF, 다단계 큐  
  
> 비선점형 방식  

비선점형 방식: 프로세스가 스스로 CPU 소유권을 포기하는 방식이며 강제로 프로세스를 중지하지  
않는다. 따라서 컨텍스트 스위칭으로 인한 부하가 적다.  
*컨텍스트 스위칭: PCB(운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터)를 교환하는  
과정이다.  
  
FCFS(First Come First Served): 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘이다.  
길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect)가 발생하기도 한다.  
SJF(Shortest Job First): 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘이다.  
긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 일어나며 평균 대기 시간이 가장 짧다.  
하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행했던 시간을 토대로 추측해서 사용한다.  
우선순위: 기존 SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상이 존재했다.  이런 오래된 작업일수록 우선순위를 높이는 방법(aging)을 적용해 단점을 보완한 알고리즘이다.  
  
> 선점형 방식  

현대 운영체제가 사용하는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고  
강제로 다른 프로세스에 CPU 소유권을 할당하는 것이다.  
  
라운드로빈: 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면  
다시 준비 큐의 뒤로 가는 알고리즘이다.  
Ex) q만큼의 할당 시간이 부여되었고 N개의 프로세스가 운영된다고 할 때 (n-1)*q 시간이 지나면  
자기 차례가 온다. 할당 시간이 너무 크면 FCFS가 되고 짧으면 컨텍스트 스위칭이 잦아져서  
오버헤드, 즉 비용이 커진다. 일반적으로 전체 작업 시간은 길어지지만 평균 응답시간은 짧아진다.  
이 알고리즘은 로드 밸런서에서 트래픽 분산 알고리즘으로도 사용된다.  
또한 라운드 로빈은 현대 컴퓨터가 쓰는 우선순위 스케줄링 방식이다.  
  
SRF: SJF는 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음  
짧은 작업을 이어나가는데, SRF는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고  
해당 프로세스를 수행하는 알고리즘이다.  
  
다단계 큐: 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른  
스케줄링 알고리즘을 적용한 것을 말한다.  큐 간의 프로세스 이동이 안되므로 스케줄링 부담이  
적지만 유연성이 떨어진다.  
  
참고 출처:  
https://velog.io/@goban/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%EB%8F%99%EC%8B%9C%EC%84%B1  
https://ajdkfl6445.gitbook.io/study/web/browser-rendering  
https://a-researcher.tistory.com/30  
https://itwiki.kr/w/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4  

