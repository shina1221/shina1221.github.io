---
layout: post
title: 메모리02
date: 2023-08-14 19:20:23 +0900
category: CS
---
# 면접을 위한 CS 전공지식 노트  
> 메모리 관리  

가상의 메모리: 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화해 이를 사용하는 사용자들에게 매우 큰  
메모리로 보이게 만드는 것이다. 이때 가상적으로 주어진 주소를 가상 주소(logical address)라고 하며,  
실제 메모리상에 있는 주소를 실제 주소(physical address)라고 한다. 
   
가상주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며 이 덕분에 사용자는 실제 주소를 의식할 필요없이  
프로그램을 구축할 수 있게 된다.  
*메모리관리장치: 시스템의 메모리 소스를 효율적으로 관리하고 할당하는것으로 CPU가 메모리에  
접근하는 것을 관리하는 하드웨어 부품이다.     
  
가상메모리는 가상주소와 실제주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리된다.  
이때 속도 향상을 위해 TLB를 쓴다.  
*TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지  
가지 않도록 해 속도를 향상시킬 수 있는 캐시계층이다.  
  
가상메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다.  
스와핑: 페이지 폴트를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고,  
사용하지 않으면 다시 하드디스크로 내림을 반복해 RAM을 효과적으로 관리하는 것이다.    
  
5개의 프로세스가 유저공간에 있을때 메모리가 꽉찬 상태에서 6번째 프로세스를 실행하려 한다면 
현재 꽉찬 공간에서 가장 안쓰는 프로세스를 잠깐 다른데에 둬서 6번째 프로세스를 실행할 수 있는 공간을 만들것이다.  
  
페이지 폴트: 프로세스의 주소공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 때 발생하는 것이다.  
이때 운영체제는 해당 데이터를 메모리로 가져와서 페이지 폴트가 전혀 발생하지 않았던 것처럼 프로그램이 작동하게 해준다.   
1. CPU는 물리 메모리를 확인해 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알린다.  
2. 운영제체는 CPU의 동작을 잠시 멈춘다.  
3. 운영체제는 페이지 테이블을 확인해 가상 메모리에 페이지가 존재하는지 확인하고,  
   없으면 프로세스를 중단하고 현재 물리 메모리에 비어있는 프레임이 있는지 찾는다.  
   물리 메모리에도 없다면 스와핑이 발생한다.  
4. 비어있는 프레임에 해당 페이지를 로드하고 페이지 테이블을 최신화한다.  
5. 중단되었던 CPU를 다시 시작한다.  
  
*트랩: 소프트웨어 인터럽트라고도 하며 프로세스 오류 등으로 프로세스가 시스템콜을 호출(커널 접근)할 때 발동한다.  
*페이지: 가상 메모리를 사용하는 최소 크기 단위  
*프레임: 실제 메모리를 사용하는 최소 크기 단위    
*주소공간: 물리적 메모리나 가상메모리 등 다른 논리적 실체나 물리적 실체에 대응되는 주소의 범위를 정의한 공간이다.  
  
스레싱: 메모리의 페이지 폴트율이 높은 것을 의미한다.  
스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생한다.  
또한 페이지 폴트가 일어나면 CPU 이용률이 낮아지고 CPU에 여유가 있다고 판단해 운영체제는 가용성을 더 높이기 위해  
더 많은 프로세스를 메모리에 올리게되며 이를 반복하고 스레싱이 일어난다.  
이를 해결하기 위해선 메모리를 늘리거나 HDD를 SDD로 바꾸는 방법이 있고   
운영체제에서는 작업 세트와 PFF로 해결할 수 있다.  
  
작업 세트: 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는것이다.  
PFF(Page Fault Frequency): 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법이다.  
만약 상한선에 도달한다면 페이지를 늘리고 하한선에 도달한다면 페이지를 줄이는 방식이다.  
  
> 메모리 할당  

메모리에 프로그램을 할당할 땐 시작 메모리 위치, 메모리의 할당 크기를기반으로 할당한다.  
이는 연속할당과 불연속 할당으로 나뉜다.  
  
연속할당: 메모리에 연속적으로(순차적으로 이어서) 공간을 할당하는 것이다.  
이는 메모리를 미리 나눠 관리하는 고정 분할 방식과   
매 시점에 프로그램 크기에 맞게 메모리를 분할해 사용하는 가변분할 방식이 있다.  
  
고정 분할 방식: 메모리를 미리 나눠 관리하는 방식으로 메모리가 미리 나뉘어 있기 때문에 융통성이 없고 내부 단변화가 발생한다.  
*내부단편화: 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상이다.  
  
가변 분할 방식: 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하며 외부 단편화가 발생할 수 있다.  
-최초적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당한다.  
-최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.  
-최악적합: 프로세스의 크기와 가장 맘ㄶ이 차이가 나는 홀에 할당한다.  
*외부단편화: 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상이다.  
*홀: 할당할 수 있는 비어있는 메모리공간이다.  
  
불연속 할당: 메모리를 연속적으로 할당하지 않는 방식이다. 페이징, 세그멘테이션, 페이지드 세그멘테이션 기법이 존재한다.   
현대 운영체제가 쓰고 있는 방법으로 페이징 기법이 존재한다. 메모리를 동일한 크기의 페이지(보통 40KB)로 나누고  
프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당한다.  
  
페이징: 동일한 크기의 페이지 단위로 나눠 메모리의 서로 다른 위치에 프로세스를 할당한다.  
홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.  
  
세그멘테이션: 페이지 단위가 아닌 세그먼트로 나누는 방식으로  
프로세스는 코드, 데이터, 스택, 힙 등으로 이뤄지는데 코드와 데이터 등 이를 기반으로 나눌 수도 있고,  
함수 단위로 나눌 수도 있다. 공유와 보안측면에서 좋지만 홀 크기가 균일하지 않은 문제가 발생한다.  

> 페이지 교체 알고리즘     

메모리는 한정되어 있기 대문에 스와핑이 많이 일어난다. 스와핑은 페이지 교체 알고리즘을 기반으로 일어난다.  
  
오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다.  
미래에 사용되는 프로세스를 사용자는 알 수 없지만 다른 알고리즘과의 성능 비교에 대한 기준을 제공한다.  
  
FIFO:선입선출, 가장 먼저 들어온 페이지를 교체 영역에 가장 먼저 놓는 방법이다.  
LRU(Least Recentle Used): 참조가 가장 오래된 페이지를 바꾼다. 이때 오래된 것을 파악하기 위해 각 페이지마다.  
계수기, 스택을 둬야한다. 해시테이블과 이중 연결 리스트 두가지 자료구조로 구현하는데  
해시테이블은  이중 연결 리스트에서 빠르게 찾을 수 있도록 쓰고,  
이중 연결 리스트는 한정된 메모리를 나타낸다.  
*데이터 계수기: 데이터를 액세스할 때 기억 장소의 번지를 유지하거나 식별하기 위해 사용되는 계수기이며  
프로그램 계수기는 컴퓨터 내부의 특정 레지스터를 사용하는 반면, 데이터 계수기는 메모리상의 불특정한 곳에 정의하여 사용된다. 
    
NUR(Not Used Recently): LRU에서 발전한 알고리즘으로 0과 1을 가진 비트를 둔다. 1은 최근에 참조되었고 0은 참조되지 않음을 의미한다.  
시계방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘이다.  
  
LFU(Least Frequency Used):가장 참조 횟수가 적은 페이지를 교체한다.  
  
참고 출처:  
https://resilient-923.tistory.com/397  

